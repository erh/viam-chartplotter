diff --git a/src/marineMap.svelte b/src/marineMap.svelte
index 863adf6..7259c26 100644
--- a/src/marineMap.svelte
+++ b/src/marineMap.svelte
@@ -1,510 +1,767 @@
 <script lang="ts">
-
- import { onMount } from 'svelte';
-import type { BoatInfo } from './lib/BoatInfo';
- 
- import Collection from 'ol/Collection.js';
- import {useGeographic} from 'ol/proj.js';
- import 'ol/ol.css';
- import ScaleLine from 'ol/control/ScaleLine.js';
- import {defaults as defaultControls} from 'ol/control/defaults.js';
- import Map from 'ol/Map';
- import View from 'ol/View';
- import TileLayer from 'ol/layer/Tile';
- import Point from 'ol/geom/Point.js';
- import Circle from 'ol/geom/Circle.js';
- import LineString from 'ol/geom/LineString.js';
- import TileWMS from 'ol/source/TileWMS.js';
- import Feature from 'ol/Feature.js';
- import VectorSource from 'ol/source/Vector.js';
- import {Vector, Tile} from 'ol/layer.js';
- import XYZ from 'ol/source/XYZ';
- import {
-   Circle as CircleStyle,
-   Fill,
-   Icon,
-   Stroke,
-   Style,
- } from 'ol/style.js';
-
- let boatImage = "boat3.jpg";
-
- let { myBoat, zoomModifier, boats, positionHistorical}: {
-  myBoat: BoatInfo;
-  zoomModifier?: number;
-  boats?: BoatInfo[];
-  positionHistorical?: { lat: number; lng: number }[];
-} = $props();
-
- $effect( () => {
-   if (myBoat.heading || myBoat.location || myBoat.speed || myBoat.route) {
-     updateFromData();
-   }
- });
-
- let mapGlobal = $state({
-
-   map: null,
-   view: null,
-
-   aisFeatures: new Collection(),
-   trackFeatures: new Collection(),
-   routeFeatures: new Collection(),
-   trackFeaturesLastCheck : new Date(0),
-   myBoatMarker: null,
-   
-
-   layerOptions: [],
-   onLayers: new Collection(),
- });
-
- let mapInternalState = {
-   inPanMode: false,
-   lastZoom: 0,
-   lastCenter: null,
-   lastPosition: [0,0],
-   trackFeatureIds : {},
- }
-
- function updateFromData() {
-   if (!mapGlobal.map) {
-     return
-   }
-
-   if (mapInternalState.lastZoom > 0 && mapInternalState.lastCenter != null && mapInternalState.lastCenter[0] != 0 ) {
-     var z = mapGlobal.view.getZoom();
-     if (z != mapInternalState.lastZoom) {
-       mapInternalState.inPanMode = true;
-     }
-     
-     var c = mapGlobal.view.getCenter();
-     var diff = pointDiff(c, mapInternalState.lastCenter);
-     if (diff > .003) {
-       mapInternalState.inPanMode = true;
-     }
-   }
-   
-   var sz = mapGlobal.map.getSize();
-   var pp = [myBoat.location[1], myBoat.location[0]];
-   mapGlobal.myBoatMarker.setGeometry(new Point(pp));
-   
-   if (!mapInternalState.inPanMode) {
-     mapGlobal.view.centerOn(pp, mapGlobal.map.getSize(), [sz[0]/2,sz[1]/2]);
-     
-     // zoom of 10 is about 30 miles
-     // zoom of 16 is city level
-     var zoom = Math.pow(Math.floor(myBoat.speed),.41)
-     zoom = Math.floor(16-zoom) + (zoomModifier||0);
-     if ( zoom <= 0 ) {
-       zoom = 1;
-     }
-     //console.log("speed: " + myBoat.speed + " zoom: " + zoom);
-     mapGlobal.view.setZoom(zoom);
-     
-     mapInternalState.lastZoom = zoom;
-     mapInternalState.lastCenter = pp;
-   }
-   
-   if (pp[0] != 0) {
-     var addToTrack = false;
-     if (mapInternalState.lastPosition[0] == 0) {
-       addToTrack = true;
-     } else {
-       var diff = pointDiff(mapInternalState.lastPosition, pp);
-       if (diff > .0000001) {
-         addToTrack = true;
-       }
-     }
-     if (addToTrack) {
-       mapGlobal.trackFeatures.push(new Feature({
-         type: "track",
-         geometry: new Circle(pp),
-       }));
-     }
-     
-     mapInternalState.lastPosition = pp;
-   }
-   
-   // route stuff
-   mapGlobal.routeFeatures.clear();
-   if (myBoat.route && myBoat.route.destinationLongitude && myBoat.route.destinationLatitude) {
-     var dest = [myBoat.route.destinationLongitude, myBoat.route.destinationLatitude];
-
-     var f = new Feature({
-       type: "track",
-       geometry: new LineString([mapInternalState.lastPosition, dest]),
-     });
-     mapGlobal.routeFeatures.push(f);
-   }
-
-   if (boats == null) {
-     mapGlobal.aisFeatures.clear();
-   } else {
-     var seen = {};
-     boats.forEach( (boat) => {
-
-       var mmsi = boat.mmsi;
-       if (!mmsi) {
-         return;
-       }
-       seen[mmsi] = true;
-       
-       for (var i = 0; i < mapGlobal.aisFeatures.getLength(); i++) {
-         var v = mapGlobal.aisFeatures.item(i);
-         if (v.get("mmsi") == mmsi) {
-           v.setGeometry(new Point([boat.location[1], boat.location[0]]));
-           return;
-         }
-       }
-
-       mapGlobal.aisFeatures.push(new Feature({
-         type: "ais",
-         name: boat.name,
-         mmsi: mmsi,
-         heading: boat.heading,
-         geometry: new Point([boat.location[1], boat.location[0]]),
-       }));
-     });
-
-     for (var i = 0; i < mapGlobal.aisFeatures.getLength(); i++) {
-       var v = mapGlobal.aisFeatures.item(i);
-       var mmsi = v.get("mmsi");
-       if (!seen[mmsi]) {
-         mapGlobal.aisFeatures.removeAt(i);
-       }
-     }
-   }
-
-   if (positionHistorical) {
-     var prev = null;
-     positionHistorical.forEach( (p) => {
-       var pp = [p.lng, p.lat];
-
-       addTrackFeature("p-" + p.lng + "-" + p.lat,
-                        new Circle(pp));
-       
-       if (prev) {
-         addTrackFeature("line-" + p.lng + "-" + p.lat, 
-                          new LineString([prev, pp]));
-       }
-       prev = pp;
-     });
-   }
-
- }
-
- function addTrackFeature(id, g) {
-   if (mapInternalState.trackFeatureIds[id] == true) {
-     return;
-   }
-
-   mapInternalState.trackFeatureIds[id] = true;
-   
-   mapGlobal.trackFeatures.push(new Feature({
-     type: "track",
-     "myid" : id,
-     geometry: g,
-   }));
- }
- 
- function getTileUrlFunction(url, type, coordinates) {
-   var x = coordinates[1];
-   var y = coordinates[2];
-   var z = coordinates[0];
-   var limit = Math.pow(2, z);
-   if (y < 0 || y >= limit) {
-     return null;
-   } else {
-     x = ((x % limit) + limit) % limit;
-     
-     var path = z + "/" + x + "/" + y + "." + type;
-     if (url instanceof Array) {
-       url = this.selectUrl(path, url);
-     }
-     return url + path;
-   }
- }
-
- function stopPanning() {
-   mapInternalState.lastZoom = 0;
-   mapInternalState.lastCenter = [0,0];
-   mapGlobal.inPanMode = false;
- }
-
- function setupLayers() {
-
-   // core open street maps
-   mapGlobal.layerOptions.push( {
-     name : "open street map",
-     on : false,
-     layer : new TileLayer({
-       opacity: .5,
-       source: new XYZ({
-         url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
-       })
-     }),
-   })
-   
-   // depth data
-   mapGlobal.layerOptions.push({
-     name: "depth",
-     on: false,
-     layer: new TileLayer({
-       opacity: .7,
-       source: new TileWMS({
-         url: 'https://geoserver.openseamap.org/geoserver/gwc/service/wms',
-         params: {'LAYERS': 'gebco2021:gebco_2021', 'VERSION':'1.1.1'},
-         ratio: 1,
-         serverType: 'geoserver',
-         hidpi: false,
-       }),
-     }),
-   })
-   
-   // harbors
-   mapGlobal.layerOptions.push({
-     name: "seamark",
-     on: false,
-     layer : new TileLayer({
-       visible: true,
-       maxZom: 19,
-       source: new XYZ({
-         tileUrlFunction: function(coordinate) {
-           return getTileUrlFunction("https://tiles.openseamap.org/seamark/", 'png', coordinate);
-   }
-       }),
-       properties: {
-         name: "seamarks",
-         layerId: 3,
-         cookieKey: "SeamarkLayerVisible",
-         checkboxId: "checkLayerSeamark",
-       }
-     }),
-   });
-   
-   mapGlobal.layerOptions.push({
-     name: "noaa",
-     on: true,
-     layer: new TileLayer({
-       opacity: .7,
-       source: new TileWMS({
-         url: "https://gis.charttools.noaa.gov/arcgis/rest/services/MCS/NOAAChartDisplay/MapServer/exts/MaritimeChartService/WMSServer",
-         //params: {'LAYERS': 'gebco2021:gebco_2021', 'VERSION':'1.1.1'},
-         //ratio: 1,
-         //serverType: 'geoserver',
-         //hidpi: false,
-       }),
-     }),
-   })
-
-   // by boat setup
-   mapGlobal.myBoatMarker = new Feature({
-     type: 'geoMarker',
-     header: 0,
-     geometry: new Point([0,0]),
-   });
-   
-   var myBoatFeatures = new Collection();
-   myBoatFeatures.push(mapGlobal.myBoatMarker);
-
-   var myBoatLayer = new Vector({
-     source: new VectorSource({
-       features: myBoatFeatures,
-     }),
-     style: function (feature) {
-       
-       var scale = 0.6;
-       var rotation = (myBoat.heading / 360) * Math.PI * 2;
-       
-       return new Style({
-         image: new Icon(
-           {
-             src:boatImage,
-             scale: scale,
-             rotation: rotation,
-         }),
-       });
-     },
-   });
-   mapGlobal.layerOptions.push({
-     name: "boat",
-     on: true,
-     layer : myBoatLayer,
-   });
-   
-   var aisLayer = new Vector({
-     source: new VectorSource({
-       features: mapGlobal.aisFeatures,
-     }),
-     style: function (feature) {
-
-       var scale = 0.25;
-       var rotation = 0;
-       
-       var h = feature.get("heading");
-       if (h >= 0 && h < 360) {
-         rotation = (h/ 360) * Math.PI * 2;
-       }
-       
-       return new Style({
-         image: new Icon(
-           {
-             src:boatImage,
-             scale: scale,
-             rotation: rotation,
-         }),
-       });
-     },
-   });
-
-   mapGlobal.layerOptions.push({
-     name: "ais",
-     on: true,
-     layer : aisLayer,
-   });
-
-   var trackLayer = new Vector({
-     source: new VectorSource({
-       features: mapGlobal.trackFeatures,
-     }),
-     style: new Style({
-       stroke: new Stroke({
-         color: "blue",
-         width: 3
-       }),
-       fill: new Fill({
-         color: "rgba(0, 255, 0, 0.1)"
-       })
-     }),
-   });
-
-   mapGlobal.layerOptions.push({
-     name: "track",
-     on: true,
-     layer : trackLayer,
-   });
-   
-   var routeLayer = new Vector({
-     source: new VectorSource({
-       features: mapGlobal.routeFeatures,
-     }),
-     style: new Style({
-       stroke: new Stroke({
-         color: "green",
-         width: 3
-       }),
-       fill: new Fill({
-         color: "rgba(0, 255, 0, 0.1)"
-       })
-     }),
-   });
-
-   mapGlobal.layerOptions.push({
-     name: "route",
-     on: true,
-     layer : routeLayer,
-   });
-
- }
-
- function findLayerByName(name) {
-   for( var l of mapGlobal.layerOptions) {
-     if (l.name == name) {
-       return l;
-     }
-   }
-   return null;
- }
-
- function findOnLayerIndexOfName(name) {
-   var l = findLayerByName(name);
-   if (l == null) {
-     return -2;
-   }
-
-   for ( var i=0; i<mapGlobal.onLayers.getLength(); i++) {
-     if (mapGlobal.onLayers.item(i).ol_uid == l.layer.ol_uid) {
-       return i;
-     }
-   }
-   return -1;
- }
- 
- function updateOnLayers() {
-   for( var l of mapGlobal.layerOptions) {
-     var idx = findOnLayerIndexOfName(l.name);
-     if (l.on) {
-       if ( idx < 0 ) {
-         mapGlobal.onLayers.push(l.layer);
-       }
-     } else {
-       if ( idx >= 0 ) {
-         mapGlobal.onLayers.removeAt(idx);
-       }
-     }
-   }
- }
- 
- function pointDiff(x, y) {
-   var a = x[0] - y[0];
-   var b = x[1] - y[1];
-   var c = a*a + b*b;
-   return Math.sqrt(c);
- }
-
- function setupMap() {
-   const urlParams = new URLSearchParams(window.location.search);
-   var temp = urlParams.get("zoomModifier");
-   if (temp) {
-     temp = parseInt(temp);
-     globalConfig.zoomModifier = temp;
-   }
-   useGeographic();
-   setupLayers();
-   
-   mapGlobal.view = new View({
-     center: [0, 0],
-     zoom: 15
-   });
-
-   updateOnLayers();
-   updateOnLayers();
-
-   var scaleThing = new ScaleLine({
-     units: "nautical",
-     bar: true,
-     text: false,
-     //minWidth: 140,
-   });
-
-   
-   mapGlobal.map = new Map({
-     target: 'map',
-     layers: mapGlobal.onLayers,
-     view: mapGlobal.view,
-     controls: defaultControls().extend([scaleThing])
-   });
-
-   console.log("setupMap finished");
- }
-
- onMount(setupMap);
-
+  import { onMount } from "svelte";
+  import type { BoatInfo } from "./lib/BoatInfo";
+
+  import Collection from "ol/Collection.js";
+  import { useGeographic } from "ol/proj.js";
+  import "ol/ol.css";
+  import ScaleLine from "ol/control/ScaleLine.js";
+  import { defaults as defaultControls } from "ol/control/defaults.js";
+  import Map from "ol/Map";
+  import View from "ol/View";
+  import TileLayer from "ol/layer/Tile";
+  import Point from "ol/geom/Point.js";
+  import Circle from "ol/geom/Circle.js";
+  import LineString from "ol/geom/LineString.js";
+  import TileWMS from "ol/source/TileWMS.js";
+  import Feature from "ol/Feature.js";
+  import VectorSource from "ol/source/Vector.js";
+  import { Vector, Tile } from "ol/layer.js";
+  import XYZ from "ol/source/XYZ";
+  import {
+    Circle as CircleStyle,
+    Fill,
+    Icon,
+    Stroke,
+    Style,
+  } from "ol/style.js";
+  import Overlay from "ol/Overlay.js";
+
+  let boatImage = "boat3.jpg";
+
+  let popupState = $state({
+    overlay: null as Overlay | null,
+    visible: false,
+    content: {
+      name: "",
+      mmsi: "",
+      speed: 0,
+      heading: 0,
+      lat: 0,
+      lng: 0,
+      isMyBoat: false,
+    },
+  });
+
+  let {
+    myBoat,
+    zoomModifier,
+    boats,
+    positionHistorical,
+  }: {
+    myBoat: BoatInfo;
+    zoomModifier?: number;
+    boats?: BoatInfo[];
+    positionHistorical?: { lat: number; lng: number }[];
+  } = $props();
+
+  $effect(() => {
+    if (myBoat.heading || myBoat.location || myBoat.speed || myBoat.route) {
+      updateFromData();
+    }
+  });
+
+  $effect(() => {
+    mapGlobal.layerOptions.forEach((l) => l.on);
+    updateOnLayers();
+  });
+
+  let mapGlobal = $state({
+    map: null,
+    view: null,
+
+    aisFeatures: new Collection(),
+    trackFeatures: new Collection(),
+    routeFeatures: new Collection(),
+    trackFeaturesLastCheck: new Date(0),
+    myBoatMarker: null,
+
+    layerOptions: [],
+    onLayers: new Collection(),
+  });
+
+  let mapInternalState = {
+    inPanMode: false,
+    lastZoom: 0,
+    lastCenter: null,
+    lastPosition: [0, 0],
+    trackFeatureIds: {},
+  };
+
+  function updateFromData() {
+    if (!mapGlobal.map) {
+      return;
+    }
+
+    if (
+      mapInternalState.lastZoom > 0 &&
+      mapInternalState.lastCenter != null &&
+      mapInternalState.lastCenter[0] != 0
+    ) {
+      var z = mapGlobal.view.getZoom();
+      if (z != mapInternalState.lastZoom) {
+        mapInternalState.inPanMode = true;
+      }
+
+      var c = mapGlobal.view.getCenter();
+      var diff = pointDiff(c, mapInternalState.lastCenter);
+      if (diff > 0.003) {
+        mapInternalState.inPanMode = true;
+      }
+    }
+
+    var sz = mapGlobal.map.getSize();
+    var pp = [myBoat.location[1], myBoat.location[0]];
+    mapGlobal.myBoatMarker.setGeometry(new Point(pp));
+
+    if (!mapInternalState.inPanMode) {
+      mapGlobal.view.centerOn(pp, mapGlobal.map.getSize(), [
+        sz[0] / 2,
+        sz[1] / 2,
+      ]);
+
+      // zoom of 10 is about 30 miles
+      // zoom of 16 is city level
+      var zoom = Math.pow(Math.floor(myBoat.speed), 0.41);
+      zoom = Math.floor(16 - zoom) + (zoomModifier || 0);
+      if (zoom <= 0) {
+        zoom = 1;
+      }
+      //console.log("speed: " + myBoat.speed + " zoom: " + zoom);
+      mapGlobal.view.setZoom(zoom);
+
+      mapInternalState.lastZoom = zoom;
+      mapInternalState.lastCenter = pp;
+    }
+
+    if (pp[0] != 0) {
+      var addToTrack = false;
+      if (mapInternalState.lastPosition[0] == 0) {
+        addToTrack = true;
+      } else {
+        var diff = pointDiff(mapInternalState.lastPosition, pp);
+        if (diff > 0.0000001) {
+          addToTrack = true;
+        }
+      }
+      if (addToTrack) {
+        mapGlobal.trackFeatures.push(
+          new Feature({
+            type: "track",
+            geometry: new Circle(pp),
+          })
+        );
+      }
+
+      mapInternalState.lastPosition = pp;
+    }
+
+    // route stuff
+    mapGlobal.routeFeatures.clear();
+    if (
+      myBoat.route &&
+      myBoat.route.destinationLongitude &&
+      myBoat.route.destinationLatitude
+    ) {
+      var dest = [
+        myBoat.route.destinationLongitude,
+        myBoat.route.destinationLatitude,
+      ];
+
+      var f = new Feature({
+        type: "track",
+        geometry: new LineString([mapInternalState.lastPosition, dest]),
+      });
+      mapGlobal.routeFeatures.push(f);
+    }
+
+    if (boats == null) {
+      mapGlobal.aisFeatures.clear();
+    } else {
+      var seen = {};
+      boats.forEach((boat) => {
+        var mmsi = boat.mmsi;
+        if (!mmsi) {
+          return;
+        }
+        seen[mmsi] = true;
+
+        for (var i = 0; i < mapGlobal.aisFeatures.getLength(); i++) {
+          var v = mapGlobal.aisFeatures.item(i);
+          if (v.get("mmsi") == mmsi) {
+            v.setGeometry(new Point([boat.location[1], boat.location[0]]));
+            return;
+          }
+        }
+
+        mapGlobal.aisFeatures.push(
+          new Feature({
+            type: "ais",
+            name: boat.name,
+            mmsi: mmsi,
+            speed: boat.speed,
+            heading: boat.heading,
+            geometry: new Point([boat.location[1], boat.location[0]]),
+          })
+        );
+      });
+
+      for (var i = 0; i < mapGlobal.aisFeatures.getLength(); i++) {
+        var v = mapGlobal.aisFeatures.item(i);
+        var mmsi = v.get("mmsi");
+        if (!seen[mmsi]) {
+          mapGlobal.aisFeatures.removeAt(i);
+        }
+      }
+    }
+
+    if (positionHistorical) {
+      var prev = null;
+      positionHistorical.forEach((p) => {
+        var pp = [p.lng, p.lat];
+
+        addTrackFeature("p-" + p.lng + "-" + p.lat, new Circle(pp));
+
+        if (prev) {
+          addTrackFeature(
+            "line-" + p.lng + "-" + p.lat,
+            new LineString([prev, pp])
+          );
+        }
+        prev = pp;
+      });
+    }
+  }
+
+  function addTrackFeature(id, g) {
+    if (mapInternalState.trackFeatureIds[id] == true) {
+      return;
+    }
+
+    mapInternalState.trackFeatureIds[id] = true;
+
+    mapGlobal.trackFeatures.push(
+      new Feature({
+        type: "track",
+        myid: id,
+        geometry: g,
+      })
+    );
+  }
+
+  function getTileUrlFunction(url, type, coordinates) {
+    var x = coordinates[1];
+    var y = coordinates[2];
+    var z = coordinates[0];
+    var limit = Math.pow(2, z);
+    if (y < 0 || y >= limit) {
+      return null;
+    } else {
+      x = ((x % limit) + limit) % limit;
+
+      var path = z + "/" + x + "/" + y + "." + type;
+      if (url instanceof Array) {
+        url = this.selectUrl(path, url);
+      }
+      return url + path;
+    }
+  }
+
+  function stopPanning() {
+    mapInternalState.lastZoom = 0;
+    mapInternalState.lastCenter = [0, 0];
+    mapGlobal.inPanMode = false;
+  }
+
+  function setupLayers() {
+    // core open street maps
+    mapGlobal.layerOptions.push({
+      name: "open street map",
+      on: false,
+      layer: new TileLayer({
+        opacity: 0.5,
+        source: new XYZ({
+          url: "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
+        }),
+      }),
+    });
+
+    // depth data
+    mapGlobal.layerOptions.push({
+      name: "depth",
+      on: false,
+      layer: new TileLayer({
+        opacity: 0.7,
+        source: new TileWMS({
+          url: "https://geoserver.openseamap.org/geoserver/gwc/service/wms",
+          params: { LAYERS: "gebco2021:gebco_2021", VERSION: "1.1.1" },
+          ratio: 1,
+          serverType: "geoserver",
+          hidpi: false,
+        }),
+      }),
+    });
+
+    // harbors
+    mapGlobal.layerOptions.push({
+      name: "seamark",
+      on: false,
+      layer: new TileLayer({
+        visible: true,
+        maxZom: 19,
+        source: new XYZ({
+          tileUrlFunction: function (coordinate) {
+            return getTileUrlFunction(
+              "https://tiles.openseamap.org/seamark/",
+              "png",
+              coordinate
+            );
+          },
+        }),
+        properties: {
+          name: "seamarks",
+          layerId: 3,
+          cookieKey: "SeamarkLayerVisible",
+          checkboxId: "checkLayerSeamark",
+        },
+      }),
+    });
+
+    mapGlobal.layerOptions.push({
+      name: "noaa",
+      on: true,
+      layer: new TileLayer({
+        opacity: 0.7,
+        source: new TileWMS({
+          url: "https://gis.charttools.noaa.gov/arcgis/rest/services/MCS/NOAAChartDisplay/MapServer/exts/MaritimeChartService/WMSServer",
+          //params: {'LAYERS': 'gebco2021:gebco_2021', 'VERSION':'1.1.1'},
+          //ratio: 1,
+          //serverType: 'geoserver',
+          //hidpi: false,
+        }),
+      }),
+    });
+
+    // by boat setup
+    mapGlobal.myBoatMarker = new Feature({
+      type: "geoMarker",
+      header: 0,
+      geometry: new Point([0, 0]),
+    });
+
+    var myBoatFeatures = new Collection();
+    myBoatFeatures.push(mapGlobal.myBoatMarker);
+
+    var myBoatLayer = new Vector({
+      source: new VectorSource({
+        features: myBoatFeatures,
+      }),
+      style: function (feature) {
+        var scale = 0.6;
+        var rotation = (myBoat.heading / 360) * Math.PI * 2;
+
+        return new Style({
+          image: new Icon({
+            src: boatImage,
+            scale: scale,
+            rotation: rotation,
+          }),
+        });
+      },
+    });
+    mapGlobal.layerOptions.push({
+      name: "boat",
+      on: true,
+      layer: myBoatLayer,
+    });
+
+    var aisLayer = new Vector({
+      source: new VectorSource({
+        features: mapGlobal.aisFeatures,
+      }),
+      style: function (feature) {
+        var scale = 0.25;
+        var rotation = 0;
+
+        var h = feature.get("heading");
+        if (h >= 0 && h < 360) {
+          rotation = (h / 360) * Math.PI * 2;
+        }
+
+        return new Style({
+          image: new Icon({
+            src: boatImage,
+            scale: scale,
+            rotation: rotation,
+          }),
+        });
+      },
+    });
+
+    mapGlobal.layerOptions.push({
+      name: "ais",
+      on: true,
+      layer: aisLayer,
+    });
+
+    var trackLayer = new Vector({
+      source: new VectorSource({
+        features: mapGlobal.trackFeatures,
+      }),
+      style: new Style({
+        stroke: new Stroke({
+          color: "blue",
+          width: 3,
+        }),
+        fill: new Fill({
+          color: "rgba(0, 255, 0, 0.1)",
+        }),
+      }),
+    });
+
+    mapGlobal.layerOptions.push({
+      name: "track",
+      on: true,
+      layer: trackLayer,
+    });
+
+    var routeLayer = new Vector({
+      source: new VectorSource({
+        features: mapGlobal.routeFeatures,
+      }),
+      style: new Style({
+        stroke: new Stroke({
+          color: "green",
+          width: 3,
+        }),
+        fill: new Fill({
+          color: "rgba(0, 255, 0, 0.1)",
+        }),
+      }),
+    });
+
+    mapGlobal.layerOptions.push({
+      name: "route",
+      on: true,
+      layer: routeLayer,
+    });
+  }
+
+  function findLayerByName(name) {
+    for (var l of mapGlobal.layerOptions) {
+      if (l.name == name) {
+        return l;
+      }
+    }
+    return null;
+  }
+
+  function findOnLayerIndexOfName(name) {
+    var l = findLayerByName(name);
+    if (l == null) {
+      return -2;
+    }
+
+    for (var i = 0; i < mapGlobal.onLayers.getLength(); i++) {
+      if (mapGlobal.onLayers.item(i).ol_uid == l.layer.ol_uid) {
+        return i;
+      }
+    }
+    return -1;
+  }
+
+  function updateOnLayers() {
+    for (var l of mapGlobal.layerOptions) {
+      var idx = findOnLayerIndexOfName(l.name);
+      if (l.on) {
+        if (idx < 0) {
+          mapGlobal.onLayers.push(l.layer);
+        }
+      } else {
+        if (idx >= 0) {
+          mapGlobal.onLayers.removeAt(idx);
+        }
+      }
+    }
+  }
+
+  function pointDiff(x, y) {
+    var a = x[0] - y[0];
+    var b = x[1] - y[1];
+    var c = a * a + b * b;
+    return Math.sqrt(c);
+  }
+
+  function setupMap() {
+    const urlParams = new URLSearchParams(window.location.search);
+    var temp = urlParams.get("zoomModifier");
+    if (temp) {
+      temp = parseInt(temp);
+      globalConfig.zoomModifier = temp;
+    }
+    useGeographic();
+    setupLayers();
+
+    mapGlobal.view = new View({
+      center: [0, 0],
+      zoom: 15,
+    });
+
+    updateOnLayers();
+    updateOnLayers();
+
+    var scaleThing = new ScaleLine({
+      units: "nautical",
+      bar: true,
+      text: false,
+      //minWidth: 140,
+    });
+
+    mapGlobal.map = new Map({
+      target: "map",
+      layers: mapGlobal.onLayers,
+      view: mapGlobal.view,
+      controls: defaultControls().extend([scaleThing]),
+    });
+
+    // Setup popup overlay
+    const popupElement = document.getElementById("boat-popup");
+    popupState.overlay = new Overlay({
+      element: popupElement,
+      autoPan: false,
+      positioning: "bottom-center",
+      offset: [0, -15],
+    });
+    mapGlobal.map.addOverlay(popupState.overlay);
+
+    // Click handler for boat features
+    mapGlobal.map.on("click", function (evt) {
+      const feature = mapGlobal.map.forEachFeatureAtPixel(
+        evt.pixel,
+        function (f) {
+          const type = f.get("type");
+          if (type === "ais" || type === "geoMarker") {
+            return f;
+          }
+          return null;
+        }
+      );
+
+      if (feature) {
+        const type = feature.get("type");
+        const geom = feature.getGeometry();
+        const coords = geom.getCoordinates();
+
+        if (type === "geoMarker") {
+          popupState.content = {
+            name: "My Boat",
+            mmsi: "",
+            speed: myBoat.speed,
+            heading: myBoat.heading,
+            lat: coords[1],
+            lng: coords[0],
+            isMyBoat: true,
+          };
+        } else {
+          popupState.content = {
+            name: feature.get("name") || "Unknown",
+            mmsi: feature.get("mmsi") || "",
+            speed: feature.get("speed") || 0,
+            heading: feature.get("heading") || 0,
+            lat: coords[1],
+            lng: coords[0],
+            isMyBoat: false,
+          };
+        }
+        popupState.visible = true;
+        popupState.overlay.setPosition(coords);
+      } else {
+        closePopup();
+      }
+    });
+
+    // Change cursor on hover over boats
+    mapGlobal.map.on("pointermove", function (evt) {
+      const hit = mapGlobal.map.hasFeatureAtPixel(evt.pixel, {
+        layerFilter: (layer) => {
+          return (
+            layer
+              .getSource()
+              ?.getFeatures?.()
+              ?.some?.(
+                (f) => f.get("type") === "ais" || f.get("type") === "geoMarker"
+              ) ?? false
+          );
+        },
+      });
+      mapGlobal.map.getTargetElement().style.cursor = hit ? "pointer" : "";
+    });
+
+    console.log("setupMap finished");
+  }
+
+  function closePopup() {
+    popupState.visible = false;
+    if (popupState.overlay) {
+      popupState.overlay.setPosition(undefined);
+    }
+  }
+
+  function formatCoord(val: number, isLat: boolean): string {
+    const dir = isLat ? (val >= 0 ? "N" : "S") : val >= 0 ? "E" : "W";
+    return Math.abs(val).toFixed(4) + "° " + dir;
+  }
+
+  onMount(setupMap);
 </script>
 
-<div id="map-container" class="relative lg:col-span-3 row-span-3 lg:row-span-5 border border-dark">
+<div
+  id="map-container"
+  class="relative lg:col-span-3 row-span-3 lg:row-span-5 border border-dark"
+>
   <div id="map" class="min-h-[50dvh] h-fit bg-white"></div>
+
+  <!-- Boat Info Popup -->
+  <div id="boat-popup" class="boat-popup" class:hidden={!popupState.visible}>
+    <button class="popup-closer" onclick={closePopup}>✕</button>
+    <div class="popup-content">
+      <h3 class="popup-title">{popupState.content.name}</h3>
+      {#if !popupState.content.isMyBoat && popupState.content.mmsi}
+        <div class="popup-row">
+          <span class="popup-label">MMSI</span>
+          <span class="popup-value">{popupState.content.mmsi}</span>
+        </div>
+      {/if}
+      <div class="popup-row">
+        <span class="popup-label">SPD</span>
+        <span class="popup-value">{popupState.content.speed.toFixed(1)} kn</span
+        >
+      </div>
+      <div class="popup-row">
+        <span class="popup-label">HDG</span>
+        <span class="popup-value">{popupState.content.heading.toFixed(0)}°</span
+        >
+      </div>
+      <div class="popup-row">
+        <span class="popup-label">LAT</span>
+        <span class="popup-value"
+          >{formatCoord(popupState.content.lat, true)}</span
+        >
+      </div>
+      <div class="popup-row">
+        <span class="popup-label">LNG</span>
+        <span class="popup-value"
+          >{formatCoord(popupState.content.lng, false)}</span
+        >
+      </div>
+    </div>
+    <div class="popup-arrow"></div>
+  </div>
+
   <div class="absolute bottom-0 right-0">
     {#if mapInternalState.inPanMode}
       <div>
-        <button on:click="{stopPanning}">Stop Panning</button>
+        <button onclick={stopPanning}>Stop Panning</button>
       </div>
     {/if}
     {#each mapGlobal.layerOptions as l, idx}
       <div>
-        <input type="checkbox" bind:checked={mapGlobal.layerOptions[idx].on}>
+        <input type="checkbox" bind:checked={mapGlobal.layerOptions[idx].on} />
         {l.name}
       </div>
     {/each}
   </div>
 </div>
+
+<style>
+  .boat-popup {
+    position: absolute;
+    background: rgba(15, 23, 42, 0.95);
+    backdrop-filter: blur(8px);
+    color: white;
+    border-radius: 4px;
+    padding: 10px 12px;
+    min-width: 160px;
+    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
+    border: 1px solid rgba(255, 255, 255, 0.08);
+    font-family:
+      system-ui,
+      -apple-system,
+      sans-serif;
+    z-index: 1000;
+    transform: translate(-50%, -100%);
+    margin-bottom: 50px;
+  }
+
+  .boat-popup.hidden {
+    display: none;
+  }
+
+  .popup-closer {
+    position: absolute;
+    top: 6px;
+    right: 8px;
+    background: none;
+    border: none;
+    color: rgba(255, 255, 255, 0.4);
+    font-size: 12px;
+    cursor: pointer;
+    padding: 2px;
+    line-height: 1;
+    transition: color 0.15s;
+  }
+
+  .popup-closer:hover {
+    color: white;
+  }
+
+  .popup-content {
+    display: flex;
+    flex-direction: column;
+    gap: 3px;
+  }
+
+  .popup-title {
+    font-size: 13px;
+    font-weight: 600;
+    margin: 0 0 4px 0;
+    padding-right: 16px;
+    color: #38bdf8;
+    letter-spacing: 0.01em;
+  }
+
+  .popup-row {
+    display: flex;
+    justify-content: space-between;
+    align-items: baseline;
+    gap: 16px;
+  }
+
+  .popup-label {
+    color: rgba(255, 255, 255, 0.5);
+    font-size: 10px;
+    text-transform: uppercase;
+    letter-spacing: 0.05em;
+    min-width: 28px;
+  }
+
+  .popup-value {
+    font-weight: 500;
+    font-size: 12px;
+    text-align: right;
+    font-variant-numeric: tabular-nums;
+    font-family: ui-monospace, monospace;
+  }
+
+  .popup-arrow {
+    position: absolute;
+    bottom: -5px;
+    left: 50%;
+    transform: translateX(-50%);
+    width: 0;
+    height: 0;
+    border-left: 5px solid transparent;
+    border-right: 5px solid transparent;
+    border-top: 5px solid rgba(15, 23, 42, 0.95);
+  }
+</style>
diff --git a/src/output.css b/src/output.css
index 558bf42..72cdae5 100644
--- a/src/output.css
+++ b/src/output.css
@@ -107,7 +107,7 @@
 }
 
 /*
-! tailwindcss v3.4.18 | MIT License | https://tailwindcss.com
+! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com
 */
 
 /*
@@ -669,10 +669,6 @@ video {
   visibility: hidden;
 }
 
-.collapse {
-  visibility: collapse;
-}
-
 .fixed {
   position: fixed;
 }
@@ -685,10 +681,6 @@ video {
   position: relative;
 }
 
-.inset-0 {
-  inset: 0px;
-}
-
 .inset-x-0 {
   left: 0px;
   right: 0px;
@@ -734,14 +726,6 @@ video {
   left: 0.2rem;
 }
 
-.left-\[189px\] {
-  left: 189px;
-}
-
-.left-\[199px\] {
-  left: 199px;
-}
-
 .left-auto {
   left: auto;
 }
@@ -758,10 +742,6 @@ video {
   right: 0.5rem;
 }
 
-.right-2\.5 {
-  right: 0.625rem;
-}
-
 .right-4 {
   right: 1rem;
 }
@@ -782,14 +762,6 @@ video {
   top: 50%;
 }
 
-.top-16 {
-  top: 4rem;
-}
-
-.top-2\.5 {
-  top: 0.625rem;
-}
-
 .top-4 {
   top: 1rem;
 }
@@ -814,6 +786,10 @@ video {
   z-index: 50;
 }
 
+.z-\[9999\] {
+  z-index: 9999;
+}
+
 .z-max {
   z-index: 1000;
 }
@@ -826,11 +802,6 @@ video {
   margin: 0px;
 }
 
-.mx-4 {
-  margin-left: 1rem;
-  margin-right: 1rem;
-}
-
 .mx-auto {
   margin-left: auto;
   margin-right: auto;
@@ -970,11 +941,6 @@ video {
   display: none;
 }
 
-.size-3\.5 {
-  width: 0.875rem;
-  height: 0.875rem;
-}
-
 .size-4 {
   width: 1rem;
   height: 1rem;
@@ -1033,14 +999,6 @@ video {
   height: 24px;
 }
 
-.h-\[32px\] {
-  height: 32px;
-}
-
-.h-\[46px\] {
-  height: 46px;
-}
-
 .h-\[50dvh\] {
   height: 50dvh;
 }
@@ -1070,10 +1028,6 @@ video {
   height: 1px;
 }
 
-.h-screen {
-  height: 100vh;
-}
-
 .max-h-36 {
   max-height: 9rem;
 }
@@ -1090,10 +1044,6 @@ video {
   max-height: 600px;
 }
 
-.max-h-\[60dvh\] {
-  max-height: 60dvh;
-}
-
 .min-h-0 {
   min-height: 0px;
 }
@@ -1110,10 +1060,6 @@ video {
   min-height: 200px;
 }
 
-.min-h-\[30px\] {
-  min-height: 30px;
-}
-
 .min-h-\[4px\] {
   min-height: 4px;
 }
@@ -1174,22 +1120,6 @@ video {
   width: 18px;
 }
 
-.w-\[200px\] {
-  width: 200px;
-}
-
-.w-\[240px\] {
-  width: 240px;
-}
-
-.w-\[30px\] {
-  width: 30px;
-}
-
-.w-\[32px\] {
-  width: 32px;
-}
-
 .w-\[3px\] {
   width: 3px;
 }
@@ -1232,10 +1162,6 @@ video {
   min-width: 1200px;
 }
 
-.min-w-\[30px\] {
-  min-width: 30px;
-}
-
 .min-w-\[400px\] {
   min-width: 400px;
 }
@@ -1244,14 +1170,6 @@ video {
   max-width: 250px;
 }
 
-.max-w-\[25rem\] {
-  max-width: 25rem;
-}
-
-.max-w-\[37\.5rem\] {
-  max-width: 37.5rem;
-}
-
 .max-w-\[400px\] {
   max-width: 400px;
 }
@@ -1260,8 +1178,8 @@ video {
   max-width: 480px;
 }
 
-.max-w-\[50rem\] {
-  max-width: 50rem;
+.max-w-\[5\.5rem\] {
+  max-width: 5.5rem;
 }
 
 .max-w-\[800px\] {
@@ -1285,6 +1203,10 @@ video {
   flex-shrink: 0;
 }
 
+.flex-grow {
+  flex-grow: 1;
+}
+
 .grow {
   flex-grow: 1;
 }
@@ -1326,8 +1248,8 @@ video {
   transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
 }
 
-.-rotate-90 {
-  --tw-rotate: -90deg;
+.-rotate-\[30deg\] {
+  --tw-rotate: -30deg;
   transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
 }
 
@@ -1341,8 +1263,8 @@ video {
   transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
 }
 
-.rotate-90 {
-  --tw-rotate: 90deg;
+.rotate-\[30deg\] {
+  --tw-rotate: 30deg;
   transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
 }
 
@@ -1482,10 +1404,6 @@ video {
   gap: 0.375rem;
 }
 
-.gap-10 {
-  gap: 2.5rem;
-}
-
 .gap-2 {
   gap: 0.5rem;
 }
@@ -1517,10 +1435,6 @@ video {
   border-bottom-width: calc(1px * var(--tw-divide-y-reverse));
 }
 
-.self-start {
-  align-self: flex-start;
-}
-
 .overflow-auto {
   overflow: auto;
 }
@@ -1563,10 +1477,6 @@ video {
   white-space: pre;
 }
 
-.text-wrap {
-  text-wrap: wrap;
-}
-
 .text-nowrap {
   text-wrap: nowrap;
 }
@@ -1583,10 +1493,6 @@ video {
   border-radius: 1px;
 }
 
-.rounded-\[3px\] {
-  border-radius: 3px;
-}
-
 .rounded-full {
   border-radius: 9999px;
 }
@@ -1615,14 +1521,19 @@ video {
   border-top-width: 1px;
 }
 
-.border-\[\#D7D7D9\] {
-  --tw-border-opacity: 1;
-  border-color: rgb(215 215 217 / var(--tw-border-opacity, 1));
+.\!border-disabled-light {
+  --tw-border-opacity: 1 !important;
+  border-color: rgb(242 242 244 / var(--tw-border-opacity, 1)) !important;
 }
 
-.border-\[\#d3c1f6\] {
-  --tw-border-opacity: 1;
-  border-color: rgb(211 193 246 / var(--tw-border-opacity, 1));
+.\!border-green-100 {
+  --tw-border-opacity: 1 !important;
+  border-color: rgb(220 252 231 / var(--tw-border-opacity, 1)) !important;
+}
+
+.\!border-red-100 {
+  --tw-border-opacity: 1 !important;
+  border-color: rgb(254 226 226 / var(--tw-border-opacity, 1)) !important;
 }
 
 .border-black {
@@ -1714,19 +1625,29 @@ video {
   border-color: rgb(221 171 63 / var(--tw-border-opacity, 1));
 }
 
-.border-warning-dark {
-  --tw-border-opacity: 1;
-  border-color: rgb(166 87 15 / var(--tw-border-opacity, 1));
-}
-
 .border-warning-medium {
   --tw-border-opacity: 1;
   border-color: rgb(233 200 157 / var(--tw-border-opacity, 1));
 }
 
-.bg-\[\#7c2fca\] {
-  --tw-bg-opacity: 1;
-  background-color: rgb(124 47 202 / var(--tw-bg-opacity, 1));
+.\!bg-disabled-light {
+  --tw-bg-opacity: 1 !important;
+  background-color: rgb(242 242 244 / var(--tw-bg-opacity, 1)) !important;
+}
+
+.\!bg-gray-50 {
+  --tw-bg-opacity: 1 !important;
+  background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1)) !important;
+}
+
+.\!bg-green-50 {
+  --tw-bg-opacity: 1 !important;
+  background-color: rgb(240 253 244 / var(--tw-bg-opacity, 1)) !important;
+}
+
+.\!bg-red-50 {
+  --tw-bg-opacity: 1 !important;
+  background-color: rgb(254 242 242 / var(--tw-bg-opacity, 1)) !important;
 }
 
 .bg-\[\#80b3e5\] {
@@ -1749,25 +1670,11 @@ video {
   background-color: rgb(238 213 159 / var(--tw-bg-opacity, 1));
 }
 
-.bg-\[\#f5ebff\] {
-  --tw-bg-opacity: 1;
-  background-color: rgb(245 235 255 / var(--tw-bg-opacity, 1));
-}
-
 .bg-black {
   --tw-bg-opacity: 1;
   background-color: rgb(19 20 20 / var(--tw-bg-opacity, 1));
 }
 
-.bg-black\/40 {
-  background-color: rgb(19 20 20 / 0.4);
-}
-
-.bg-blue-500 {
-  --tw-bg-opacity: 1;
-  background-color: rgb(59 130 246 / var(--tw-bg-opacity, 1));
-}
-
 .bg-danger-dark {
   --tw-bg-opacity: 1;
   background-color: rgb(190 53 54 / var(--tw-bg-opacity, 1));
@@ -1793,6 +1700,10 @@ video {
   background-color: rgb(242 242 244 / var(--tw-bg-opacity, 1));
 }
 
+.bg-ghost-medium {
+  background-color: rgba(0,0,0,0.08);
+}
+
 .bg-gray-1 {
   --tw-bg-opacity: 1;
   background-color: rgb(247 247 248 / var(--tw-bg-opacity, 1));
@@ -1803,11 +1714,6 @@ video {
   background-color: rgb(237 238 240 / var(--tw-bg-opacity, 1));
 }
 
-.bg-gray-3 {
-  --tw-bg-opacity: 1;
-  background-color: rgb(228 228 230 / var(--tw-bg-opacity, 1));
-}
-
 .bg-gray-4 {
   --tw-bg-opacity: 1;
   background-color: rgb(215 215 217 / var(--tw-bg-opacity, 1));
@@ -1853,11 +1759,6 @@ video {
   background-color: rgb(240 253 244 / var(--tw-bg-opacity, 1));
 }
 
-.bg-green-500 {
-  --tw-bg-opacity: 1;
-  background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1));
-}
-
 .bg-info-dark {
   --tw-bg-opacity: 1;
   background-color: rgb(46 103 211 / var(--tw-bg-opacity, 1));
@@ -1883,11 +1784,6 @@ video {
   background-color: rgb(254 242 242 / var(--tw-bg-opacity, 1));
 }
 
-.bg-red-500 {
-  --tw-bg-opacity: 1;
-  background-color: rgb(239 68 68 / var(--tw-bg-opacity, 1));
-}
-
 .bg-success-dark {
   --tw-bg-opacity: 1;
   background-color: rgb(61 125 63 / var(--tw-bg-opacity, 1));
@@ -1918,8 +1814,8 @@ video {
   background-color: rgb(254 249 195 / var(--tw-bg-opacity, 1));
 }
 
-.bg-opacity-50 {
-  --tw-bg-opacity: 0.5;
+.bg-opacity-40 {
+  --tw-bg-opacity: 0.4;
 }
 
 .p-0 {
@@ -1995,16 +1891,6 @@ video {
   padding-bottom: 0.375rem;
 }
 
-.py-2 {
-  padding-top: 0.5rem;
-  padding-bottom: 0.5rem;
-}
-
-.py-2\.5 {
-  padding-top: 0.625rem;
-  padding-bottom: 0.625rem;
-}
-
 .py-3 {
   padding-top: 0.75rem;
   padding-bottom: 0.75rem;
@@ -2015,10 +1901,6 @@ video {
   padding-bottom: 1px;
 }
 
-.pb-2 {
-  padding-bottom: 0.5rem;
-}
-
 .pb-6 {
   padding-bottom: 1.5rem;
 }
@@ -2035,18 +1917,10 @@ video {
   padding-left: 0.75rem;
 }
 
-.pl-5 {
-  padding-left: 1.25rem;
-}
-
 .pl-8 {
   padding-left: 2rem;
 }
 
-.pr-0 {
-  padding-right: 0px;
-}
-
 .pr-1 {
   padding-right: 0.25rem;
 }
@@ -2164,23 +2038,23 @@ video {
   letter-spacing: 0.05em;
 }
 
-.\!text-danger-dark {
+.\!text-gray-500 {
   --tw-text-opacity: 1 !important;
-  color: rgb(190 53 54 / var(--tw-text-opacity, 1)) !important;
+  color: rgb(107 114 128 / var(--tw-text-opacity, 1)) !important;
 }
 
-.text-\[\#7c2fca\] {
-  --tw-text-opacity: 1;
-  color: rgb(124 47 202 / var(--tw-text-opacity, 1));
+.\!text-green-700 {
+  --tw-text-opacity: 1 !important;
+  color: rgb(21 128 61 / var(--tw-text-opacity, 1)) !important;
 }
 
-.text-black\/50 {
-  color: rgb(19 20 20 / 0.5);
+.\!text-red-500 {
+  --tw-text-opacity: 1 !important;
+  color: rgb(239 68 68 / var(--tw-text-opacity, 1)) !important;
 }
 
-.text-blue-600 {
-  --tw-text-opacity: 1;
-  color: rgb(37 99 235 / var(--tw-text-opacity, 1));
+.text-black\/50 {
+  color: rgb(19 20 20 / 0.5);
 }
 
 .text-danger-dark {
@@ -2374,20 +2248,15 @@ video {
   filter: none;
 }
 
-.transition {
-  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
-  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
-  transition-duration: 150ms;
-}
-
-.transition-all {
-  transition-property: all;
-  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
-  transition-duration: 150ms;
+.backdrop-filter {
+  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
+  backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
 }
 
-.transition-colors {
-  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
+.transition {
+  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
+  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
+  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
   transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
   transition-duration: 150ms;
 }
@@ -2640,6 +2509,10 @@ video {
   cursor: pointer;
 }
 
+.\[overflow-wrap\:anywhere\] {
+  overflow-wrap: anywhere;
+}
+
 #map-container {
   position: relative;
   height: 100%;
@@ -2689,7 +2562,7 @@ video {
   width: 0px;
 }
 
-.after\:border-x-2::after {
+.after\:border-x-\[2px\]::after {
   content: var(--tw-content);
   border-left-width: 2px;
   border-right-width: 2px;
@@ -2700,7 +2573,7 @@ video {
   border-bottom-width: 0;
 }
 
-.after\:border-t-2::after {
+.after\:border-t-\[2px\]::after {
   content: var(--tw-content);
   border-top-width: 2px;
 }
@@ -2752,11 +2625,6 @@ video {
   cursor: pointer;
 }
 
-.hover\:border-\[\#EBD8FF\]:hover {
-  --tw-border-opacity: 1;
-  border-color: rgb(235 216 255 / var(--tw-border-opacity, 1));
-}
-
 .hover\:border-black:hover {
   --tw-border-opacity: 1;
   border-color: rgb(19 20 20 / var(--tw-border-opacity, 1));
@@ -2772,31 +2640,11 @@ video {
   border-color: rgb(215 215 217 / var(--tw-border-opacity, 1));
 }
 
-.hover\:bg-\[\#EBD8FF\]:hover {
-  --tw-bg-opacity: 1;
-  background-color: rgb(235 216 255 / var(--tw-bg-opacity, 1));
-}
-
-.hover\:bg-\[\#F0F0F0\]:hover {
-  --tw-bg-opacity: 1;
-  background-color: rgb(240 240 240 / var(--tw-bg-opacity, 1));
-}
-
-.hover\:bg-\[\#F6C7C1\]:hover {
-  --tw-bg-opacity: 1;
-  background-color: rgb(246 199 193 / var(--tw-bg-opacity, 1));
-}
-
 .hover\:bg-\[\#aa2a2b\]:hover {
   --tw-bg-opacity: 1;
   background-color: rgb(170 42 43 / var(--tw-bg-opacity, 1));
 }
 
-.hover\:bg-\[\#d9f2e4\]:hover {
-  --tw-bg-opacity: 1;
-  background-color: rgb(217 242 228 / var(--tw-bg-opacity, 1));
-}
-
 .hover\:bg-\[\#f5dfdc\]:hover {
   --tw-bg-opacity: 1;
   background-color: rgb(245 223 220 / var(--tw-bg-opacity, 1));
@@ -2807,8 +2655,9 @@ video {
   background-color: rgb(19 20 20 / var(--tw-bg-opacity, 1));
 }
 
-.hover\:bg-danger-dark\/10:hover {
-  background-color: rgb(190 53 54 / 0.1);
+.hover\:bg-danger-dark:hover {
+  --tw-bg-opacity: 1;
+  background-color: rgb(190 53 54 / var(--tw-bg-opacity, 1));
 }
 
 .hover\:bg-ghost-light:hover {
@@ -2835,6 +2684,10 @@ video {
   background-color: rgb(241 241 244 / var(--tw-bg-opacity, 1));
 }
 
+.hover\:bg-opacity-\[0\.08\]:hover {
+  --tw-bg-opacity: 0.08;
+}
+
 .hover\:text-danger-dark:hover {
   --tw-text-opacity: 1;
   color: rgb(190 53 54 / var(--tw-text-opacity, 1));
@@ -2911,10 +2764,6 @@ video {
   outline-color: #ddab3f;
 }
 
-.focus\:outline-warning-dark:focus {
-  outline-color: #a6570f;
-}
-
 .focus\:slider-track-gray-5:focus::-webkit-slider-runnable-track {
   background: #c5c6cc;
 }
@@ -2944,11 +2793,6 @@ video {
   color: rgb(40 40 41 / var(--tw-text-opacity, 1));
 }
 
-.active\:border-\[\#EBD8FF\]:active {
-  --tw-border-opacity: 1;
-  border-color: rgb(235 216 255 / var(--tw-border-opacity, 1));
-}
-
 .active\:border-ghost-medium:active {
   border-color: rgba(0,0,0,0.08);
 }
@@ -2958,24 +2802,14 @@ video {
   border-color: rgb(215 215 217 / var(--tw-border-opacity, 1));
 }
 
-.active\:bg-\[\#9e2728\]:active {
-  --tw-bg-opacity: 1;
-  background-color: rgb(158 39 40 / var(--tw-bg-opacity, 1));
-}
-
-.active\:bg-\[\#EBD8FF\]:active {
-  --tw-bg-opacity: 1;
-  background-color: rgb(235 216 255 / var(--tw-bg-opacity, 1));
-}
-
-.active\:bg-\[\#F0A398\]:active {
+.active\:bg-\[\#000\]:active {
   --tw-bg-opacity: 1;
-  background-color: rgb(240 163 152 / var(--tw-bg-opacity, 1));
+  background-color: rgb(0 0 0 / var(--tw-bg-opacity, 1));
 }
 
-.active\:bg-\[\#d8f0e2\]:active {
+.active\:bg-\[\#9e2728\]:active {
   --tw-bg-opacity: 1;
-  background-color: rgb(216 240 226 / var(--tw-bg-opacity, 1));
+  background-color: rgb(158 39 40 / var(--tw-bg-opacity, 1));
 }
 
 .active\:bg-\[\#f6d7d3\]:active {
@@ -2987,11 +2821,6 @@ video {
   background-color: rgba(190,53,54,0.16);
 }
 
-.active\:bg-black:active {
-  --tw-bg-opacity: 1;
-  background-color: rgb(19 20 20 / var(--tw-bg-opacity, 1));
-}
-
 .active\:bg-ghost-medium:active {
   background-color: rgba(0,0,0,0.08);
 }
@@ -3122,8 +2951,3 @@ video {
     grid-template-rows: repeat(6, minmax(0, 1fr));
   }
 }
-
-.\[\&\>svg\]\:size-3\.5>svg {
-  width: 0.875rem;
-  height: 0.875rem;
-}
